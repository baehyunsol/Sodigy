use std.bool.Bool;
use std.string.String;

#[built_in]
#[lang_item("type.Int")]
pub enum Int = { _ };

// I wanted `fn neg_int(x) = x * -1;`... but that's an infinite recursion!
#[built_in]
#[impl(std.op.neg)]
#[lang_item("built_in.neg_int")]
fn neg_int(a: Int) -> Int;

#[built_in]
#[impl(std.op.add)]
#[lang_item("built_in.add_int")]
fn add_int(a: Int, b: Int) -> Int;

#[built_in]
#[impl(std.op.sub)]
#[lang_item("built_in.sub_int")]
fn sub_int(a: Int, b: Int) -> Int;

#[built_in]
#[impl(std.op.mul)]
#[lang_item("built_in.mul_int")]
fn mul_int(a: Int, b: Int) -> Int;

/// It doesn't check whether `b` is 0 or not.
/// If `b` is 0, something bad (can be worse than `panic`) will happen.
#[built_in]
#[lang_item("built_in.div_int")]
fn div_int(a: Int, b: Int) -> Int;

#[built_in]
#[impl(std.op.rem)]
#[lang_item("built_in.rem_int")]
fn rem_int(a: Int, b: Int) -> Int;

#[built_in]
#[impl(std.op.lt)]
#[lang_item("built_in.lt_int")]
fn lt_int(a: Int, b: Int) -> Bool;

#[built_in]
#[impl(std.op.eq)]
#[lang_item("built_in.eq_int")]
fn eq_int(a: Int, b: Int) -> Bool;

#[built_in]
#[impl(std.op.gt)]
#[lang_item("built_in.gt_int")]
fn gt_int(a: Int, b: Int) -> Bool;

#[impl(std.op.div)]
fn div_int_wrapper(a: Int, b: Int) -> Int = {
    if b == 0 {
        // TODO: error message
        std.panic()
    }

    else {
        div_int(a, b)
    }
};

// TODO: match is not implemented yet...
/*
fn to_string(n: Int) -> String = match n {
    ..0 => "-" ++ to_string(-n),
    0 => "0",
    1 => "1",
    2 => "2",
    3 => "3",
    4 => "4",
    5 => "5",
    6 => "6",
    7 => "7",
    8 => "8",
    9 => "9",
    _ => to_string(n / 10) ++ to_string(n % 10),
};
*/

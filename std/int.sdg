use std.bool.Bool;
use std.string.String;

#[built_in]
#[lang_item("type.Int")]
pub enum Int;

// I wanted `fn neg_int(x) = x * -1;`... but that's an infinite recursion!
#[built_in]
#[impl(std.op.neg)]
#[lang_item("built_in.neg_int")]
fn neg_int(a: Int) -> Int;

#[built_in]
#[impl(std.op.add)]
#[lang_item("built_in.add_int")]
fn add_int(a: Int, b: Int) -> Int;

#[built_in]
#[impl(std.op.sub)]
#[lang_item("built_in.sub_int")]
fn sub_int(a: Int, b: Int) -> Int;

#[built_in]
#[impl(std.op.mul)]
#[lang_item("built_in.mul_int")]
fn mul_int(a: Int, b: Int) -> Int;

/// It doesn't check whether `b` is 0 or not.
/// If `b` is 0, something bad (can be worse than `panic`) will happen.
#[built_in]
#[lang_item("built_in.div_int")]
fn div_int_built_in(a: Int, b: Int) -> Int;

#[impl(std.op.div)]
fn div_int(a: Int, b: Int) -> Int = {
    #[always]
    assert b != 0;

    div_int_built_in(a, b)
};

#[built_in]
#[lang_item("built_in.rem_int")]
fn rem_int_built_in(a: Int, b: Int) -> Int;

#[impl(std.op.rem)]
fn rem_int(a: Int, b: Int) -> Int = {
    #[always]
    assert b != 0;

    rem_int_built_in(a, b)
};

#[built_in]
#[impl(std.op.lt)]
#[lang_item("built_in.lt_int")]
fn lt_int(a: Int, b: Int) -> Bool;

#[built_in]
#[impl(std.op.eq)]
#[lang_item("built_in.eq_int")]
fn eq_int(a: Int, b: Int) -> Bool;

#[built_in]
#[impl(std.op.gt)]
#[lang_item("built_in.gt_int")]
fn gt_int(a: Int, b: Int) -> Bool;

// Sodigy can run fine without this because `std.op.leq` has a default implementation.
// But the compiler needs a lang item for leq_int, so it's implemented here.
#[impl(std.op.leq)]
#[lang_item("fn.leq_int")]
fn leq_int(a: Int, b: Int) -> Bool = !gt_int(a, b);

// Sodigy can run fine without this because `std.op.neq` has a default implementation.
// But the compiler needs a lang item for neq_int, so it's implemented here.
#[impl(std.op.neq)]
#[lang_item("fn.neq_int")]
fn neq_int(a: Int, b: Int) -> Bool = !eq_int(a, b);

// Sodigy can run fine without this because `std.op.geq` has a default implementation.
// But the compiler needs a lang item for geq_int, so it's implemented here.
#[impl(std.op.geq)]
#[lang_item("fn.geq_int")]
fn geq_int(a: Int, b: Int) -> Bool = !lt_int(a, b);

// TODO: match is not implemented yet...
/*
fn to_string(n: Int) -> String = match n {
    ..0 => "-" ++ to_string(-n),
    0 => "0",
    1 => "1",
    2 => "2",
    3 => "3",
    4 => "4",
    5 => "5",
    6 => "6",
    7 => "7",
    8 => "8",
    9 => "9",
    _ => to_string(n / 10) ++ to_string(n % 10),
};
*/

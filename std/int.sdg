use std.bool.Bool;

#[built_in]
#[lang_item("type.Int")]
pub enum Int = { _ };

// I wanted `fn neg_int(x) = x * -1;`... but that's an infinite recursion!
#[built_in]
#[impl(std.op.neg)]
#[lang_item("built_in.neg_int")]
fn neg_int(a: Int) -> Int;

#[built_in]
#[impl(std.op.add)]
#[lang_item("built_in.add_int")]
fn add_int(a: Int, b: Int) -> Int;

#[built_in]
#[impl(std.op.sub)]
#[lang_item("built_in.sub_int")]
fn sub_int(a: Int, b: Int) -> Int;

#[built_in]
#[impl(std.op.mul)]
#[lang_item("built_in.mul_int")]
fn mul_int(a: Int, b: Int) -> Int;

#[built_in]
#[impl(std.op.div)]
#[lang_item("built_in.div_int")]
fn div_int(a: Int, b: Int) -> Int;

#[built_in]
#[impl(std.op.rem)]
#[lang_item("built_in.rem_int")]
fn rem_int(a: Int, b: Int) -> Int;

#[built_in]
#[impl(std.op.lt)]
#[lang_item("built_in.lt_int")]
fn lt_int(a: Int, b: Int) -> Bool;

#[built_in]
#[impl(std.op.eq)]
#[lang_item("built_in.eq_int")]
fn eq_int(a: Int, b: Int) -> Bool;

#[built_in]
#[impl(std.op.gt)]
#[lang_item("built_in.gt_int")]
fn gt_int(a: Int, b: Int) -> Bool;

// TODO: this should be the implementation of `div_int`,
//       but the compiler isn't smart enough to compile this.
/*
#[impl(std.op.div)]
fn div_int_impl(a: Int, b: Int) -> Int = {
    if b == 0 {
        // TODO: error message
        std.panic()
    }

    else {
        div_int(a, b)
    }
};

#[built_in]
#[lang_item("built_in.div_int")]
fn div_int(a: Int, b: Int) -> Int;
*/

use std.bool.Bool;
use std.int.Int;

#[built_in]
#[lang_item("type.List")]
pub struct List = { _ };

#[built_in]
#[lang_item("built_in.init_list")]
#[lang_item_generics("built_in.init_list.generic.0")]
fn init_list<T>(/* varargs */) -> [T];

/// It assumes that `i` is non-negative and less than `ls.len()`.
/// If the assumption is wrong, something bad (can be worse than `panic`) will happen.
#[built_in]
#[lang_item("built_in.index_list")]
#[lang_item_generics("built_in.init_list.generic.0")]
fn index_list_built_in<T>(ls: [T], i: Int) -> T;

// TODO: The compiler isn't strong enough to compile these functions.
/*
#[impl(std.op.index)]
fn index_list<T>(ls: [T], i: Int) -> T = {
    if 0 <= i && i < ls.len() {
        index_list_built_in(ls, i)
    }

    else if -ls.len() <= i {
        index_list_built_in(ls, i + ls.len())
    }

    else {
        // TODO: error message
        std.panic()
    }
};

#[impl(std.op.eq)]
fn eq_list<T>(lhs: [T], rhs: [T]) -> Bool = match (lhs, rhs) {
    ([], []) => Bool.True,
    ([], _) | (_, []) => Bool.False,
    ([$l] ++ $lhs, [$r] ++ $rhs_r) => l == r && lhs == rhs,
};

#[impl(std.op.concat)]
fn concat_list<T>(lhs: [T], rhs: [T]) -> [T] = match rhs {
    [] => lhs,
    [$r] ++ $rhs => (lhs <+ [r]) ++ rhs,
};
*/

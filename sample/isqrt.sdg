let SQUARES = [
      0,   1,   4,   9,  16,
     25,  36,  49,  64,  81,
    100, 121, 144, 169, 196,
    225, 256, 289, 324, 361,
    400, 441, 484, 529, 576,
];

fn isqrt(n: Int) -> Int = match n {
    ..0 => panic(),
    ..625 => match SQUARES.binary_search(n) {
        Ok(sq) | Err(sq + 1) => sq,
    },
    ..160_000 => {
        let sub = isqrt(n >> 4) << 2;

        if (sub + 3) * (sub + 3) <= n {
            sub + 3
        } else if (sub + 2) * (sub + 2) <= n {
            sub + 2
        } else if (sub + 1) * (sub + 1) <= n {
            sub + 1
        } else {
            sub
        }
    },
    _ => {
        let lo = isqrt(n >> 8) << 4;
        let hi = lo + 16;

        let lo_d = n - lo * lo;
        let hi_d = hi * hi - n;

        lo + lo_d * 16 / (lo_d + hi_d)
    },
};

assert check_isqrt_multi([
    0, 1, 2, 3, 4,
    5, 6, 7, 8, 9,

    10, 11, 12, 13, 14,
    15, 16, 17, 18, 19,
]);
assert check_isqrt_multi([
    299, 300, 301,
    399, 400, 401,
    499, 500, 501,
    599, 600, 601,
    699, 700, 701,
]);
assert check_isqrt_multi([
    29999, 30000, 30001,
    39999, 40000, 40001,
    49999, 50000, 50001,
    59999, 60000, 60001,
    69999, 70000, 70001,
]);
assert check_isqrt_multi([
    2999999, 3000000, 3000001,
    3999999, 4000000, 4000001,
    4999999, 5000000, 5000001,
    5999999, 6000000, 6000001,
    6999999, 7000000, 7000001,
]);
assert check_isqrt_multi([
    (1 << 32) - 1, 1 << 32, (1 << 32) + 1,
    (1 << 33) - 1, 1 << 33, (1 << 33) + 1,
    (1 << 34) - 1, 1 << 34, (1 << 34) + 1,
    (1 << 35) - 1, 1 << 35, (1 << 35) + 1,
    (1 << 36) - 1, 1 << 36, (1 << 36) + 1,
]);

// bounding values
assert check_isqrt_multi([
    623, 624, 625, 626, 627,
    159_998, 159_999, 160_000, 160_001, 160_002,
]);

assert check_isqrt(1_000);
assert check_isqrt(100_000);
assert check_isqrt(10_000_000);
assert check_isqrt(1_000_000_000);
assert check_isqrt(100_000_000_000);
assert check_isqrt(10_000_000_000_000);
assert check_isqrt(1_000_000_000_000_000);
assert check_isqrt(100_000_000_000_000_000);
assert check_isqrt(10_000_000_000_000_000_000);
assert check_isqrt(1_000_000_000_000_000_000_000);
assert check_isqrt(100_000_000_000_000_000_000_000);

fn check_isqrt(n: Int) -> Bool = {
    let s = isqrt(n);

    if s * s <= n && n < (s + 1) * (s + 1) {
        True
    } else {
        panic(f"n: {n}, isqrt(n): {s}\n{s} * {s} = {s * s}, {s + 1} * {s + 1} = {(s + 1) * (s + 1)}")
    }
};

fn check_isqrt_multi(ns: [Int]) -> Bool = match ns {
    [] => True,
    [n] ++ ns => {
        assert check_isqrt(n);
        check_isqrt_multi(ns)
    },
};

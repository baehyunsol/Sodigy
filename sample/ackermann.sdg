fn ackermann(m: Int, n: Int): Int = {
    if m == 0 {
        n + 1
    } else if n == 0 {
        ackermann(m - 1, 1)
    } else {
        ackermann(m - 1, ackermann(m, n - 1))
    }
};

// mutually recursive functions
fn ackermann1(m: Int, n: Int): Int = {
    if m == 0 {
        n + 1
    } else if n == 0 {
        ackermann1(m - 1, 1)
    } else {
        ackermann2(m - 1, ackermann3(m, n - 1))
    }
};

fn ackermann2(m: Int, n: Int): Int = {
    if m == 0 {
        n + 1
    } else if n == 0 {
        ackermann2(m - 1, 1)
    } else {
        ackermann3(m - 1, ackermann1(m, n - 1))
    }
};

fn ackermann3(m: Int, n: Int): Int = {
    if m == 0 {
        n + 1
    } else if n == 0 {
        ackermann3(m - 1, 1)
    } else {
        ackermann1(m - 1, ackermann2(m, n - 1))
    }
};

@test.eq([[3, 3, 3, 3], [5, 5, 5, 5], [61, 125]])
let test_values = [
    [
        ackermann(1, 1),
        ackermann1(1, 1),
        ackermann2(1, 1),
        ackermann3(1, 1),
    ], [
        ackermann(2, 1),
        ackermann1(2, 1),
        ackermann2(2, 1),
        ackermann3(2, 1),
    ], [
        ackermann(3, 3),
        ackermann(3, 4),
    ],
];

fn main() = [
    ackermann(1, 1),
    ackermann1(3, 4),
];

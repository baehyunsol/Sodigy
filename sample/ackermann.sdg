@test.eq((1, 1), 3)
@test.eq((3, 3), 61)
fn ackermann(m: Int, n: Int): Int = match (m, n) {
    (0, n) => n + 1,
    (m, 0) => ackermann(m - 1, 1),
    _ => ackermann(m - 1, ackermann(m, n - 1)),
};

@test.eq((1, 1), 3)
@test.eq((3, 3), 61)
fn ackermann_if(m: Int, n: Int): Int = {
    if m == 0 {
        n + 1
    } else if n == 0 {
        ackermann(m - 1, 1)
    } else {
        ackermann(m - 1, ackermann(m, n - 1))
    }
};

// mutually recursive ackermann
@test.eq((2, 1), 5)
fn amr1(m: Int, n: Int): Int = match (m, n) {
    (0, n) => n + 1,
    (m, 0) => amr1(m - 1, 1),
    _ => amr2(m - 1, amr3(m, n - 1)),
};

@test.eq((3, 3), 61)
fn amr2(m: Int, n: Int): Int = match (m, n) {
    (0, n) => n + 1,
    (m, 0) => amr2(m - 1, 1),
    _ => amr3(m - 1, amr1(m, n - 1)),
};

@test.eq((3, 4), 125)
fn amr3(m: Int, n: Int): Int = {
    (0, n) => n + 1,
    (m, 0) => amr3(m - 1, 1),
    _ => amr1(m - 1, amr2(m, n - 1)),
};

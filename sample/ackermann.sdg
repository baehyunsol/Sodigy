@test.eq((1, 1), 3)
@test.eq((3, 3), 61)
fn ackermann_if(m: Int, n: Int): Int = {
    if m == 0 {
        n + 1
    } else if n == 0 {
        ackermann(m - 1, 1)
    } else {
        ackermann(m - 1, ackermann(m, n - 1))
    }
};

@test.eq((1, 1), 3)
@test.eq((3, 3), 61)
fn ackermann_match(m: Int, n: Int): Int = match (m, n) {
    (0, n) => n + 1,
    (m, 0) => ackermann_match(m - 1, 1),
    _ => ackermann_match(m - 1, ackermann_match(m, n - 1)),
};

// mutually recursive functions
@test.eq((2, 1), 5)
fn ackermann1(m: Int, n: Int): Int = {
    if m == 0 {
        n + 1
    } else if n == 0 {
        ackermann1(m - 1, 1)
    } else {
        ackermann2(m - 1, ackermann3(m, n - 1))
    }
};

@test.eq((3, 3), 61)
fn ackermann2(m: Int, n: Int): Int = {
    if m == 0 {
        n + 1
    } else if n == 0 {
        ackermann2(m - 1, 1)
    } else {
        ackermann3(m - 1, ackermann1(m, n - 1))
    }
};

@test.eq((3, 4), 125)
fn ackermann3(m: Int, n: Int): Int = {
    if m == 0 {
        n + 1
    } else if n == 0 {
        ackermann3(m - 1, 1)
    } else {
        ackermann1(m - 1, ackermann2(m, n - 1))
    }
};

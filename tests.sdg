@test.eq(43)
def functor_test: Int = {
  let adder = \{x, \{y, x + y}};
  let adder1 = adder(1);
  let adder2 = adder(2);

  adder1(20) + adder2(20)
};

@test.eq(10946)
def mutual_fibo: Int = {
    let n = 20;
    let fibo1 = \{n, if n < 2 { 1 } else { fibo1(n - 1) + fibo2(n - 2) }};
    let fibo2 = \{n, if n < 2 { 1 } else { fibo2(n - 1) + fibo1(n - 2) }};

    fibo2(n)
};

def lambdas(x: Int, y: Int): Int = \{
    \{
        \{y, z, x + y + z}
    }
};

@test.eq(111)
def lambdas_test: Int = lambdas(3, 9)()()(27, 81);

# TODO: type signatures of functors
def adder(n: Int): Func(Int, Int) = \{x: Int, x + n};

@test.eq([8, 16])
def adder_test: List(Int) = [adder(3)(5), adder(7)(9)];

@test.eq(9 + (81 + (3 + 27 + 243 + 729)))
def name_scope_test: Int = {
    let a = 3; let b = 9;
    b + {
        let b = 27; let c = 81;
        c + {
            let c = 243; let d = 729;
            a + b + c + d
        }
    }
};

@test.eq(999999999999999999999940837306036211360320144)
def big_number_test: Int = {
    let a = 31622776601683793319988;

    a * a
};

def dirty_closure(n: Int): Int = {
    let f1 = \{x, f2(x - 1)};
    let f2 = \{x, if x > 0 { 1 + f1(x - n) } else { 0 } };

    f1(100)
};

@test.eq([17, 20, 25, 33, 50])
def dirty_closure_test: List(Int) = [
    dirty_closure(5),
    dirty_closure(4),
    dirty_closure(3),
    dirty_closure(2),
    dirty_closure(1),
];
use crate::ast::NameOrigin;
use crate::expr::{Expr, ExprKind, InfixOp};
use crate::path::Path;
use crate::session::{InternedString, LocalParseSession};
use crate::span::Span;
use crate::token::{Token, TokenKind};
use crate::value::ValueKind;
use std::slice::Iter;

#[derive(Clone)]
pub struct Use {
    pub path: Path,
    pub alias: InternedString,

    pub span: Span,  // keyword `use`
}

impl Use {
    pub fn new(path: Vec<(InternedString, Span)>, alias: InternedString, span: Span) -> Self {
        assert!(!path.is_empty(), "Internal Compiler Error C992CA92C26");

        Use {
            path: Path::from_names(path),
            alias, span
        }
    }

    pub fn append_front(mut self, path: &Vec<(InternedString, Span)>) -> Self {
        self.path.append_front(&path);

        self
    }

    // used for resolving names.
    // Exprs generated by this function do not have spans: be careful
    // not to generate errors from Exprs from this
    pub fn to_path(&self) -> ExprKind {
        to_path_impl(self.path.as_ref())
    }

    pub fn iter_path(&self) -> Iter<(InternedString, Span)> {
        self.path.as_ref().iter()
    }

    pub fn dump(&self, session: &LocalParseSession) -> String {
        #[cfg(test)]
        if self.span.dump(session) != "use" {
            panic!("{}", self.span.render_err(session));
        }
        // assert_eq!(self.span.dump(session), "use");

        format!("use {} as {};", self.path.dump(session), self.alias.to_string(session))
    }
}

pub fn use_case_to_tokens(Use { path, alias, span }: Use) -> Vec<Token> {
    // `use`, PATH, `as`, ALIAS, `;`
    let mut tokens = Vec::with_capacity(path.len() * 2 + 3);

    tokens.push(Token {
        span,
        kind: TokenKind::keyword_use(),
    });

    for token in path.tokens() {
        tokens.push(token);
    }

    tokens.push(Token {
        span,
        kind: TokenKind::keyword_as(),
    });

    tokens.push(Token {
        span,
        kind: TokenKind::Identifier(alias),
    });

    tokens.push(Token {
        span,
        kind: TokenKind::semi_colon(),
    });

    tokens
}

macro_rules! new_path {
    ($p0: expr) => {
        new_path!(global, $p0.0)
    };
    (global, $p0: expr) => {
        ExprKind::Value(ValueKind::Identifier($p0, NameOrigin::Global))
    };
    (sub, $p0: expr) => {
        ExprKind::Value(ValueKind::Identifier($p0, NameOrigin::SubPath))
    };
    ($p0: expr, $p1: expr) => {
        ExprKind::Infix(
            InfixOp::Path,
            Box::new(Expr {
                kind: new_path!(global, $p0.0),
                span: $p0.1,
            }),
            Box::new(Expr {
                kind: new_path!(sub, $p1.0),
                span: $p1.1,
            }),
        )
    };
    (recurs, $ph: expr, $pt: expr) => {
        ExprKind::Infix(
            InfixOp::Path,
            Box::new(Expr {
                kind: $ph,
                span: Span::dummy(),
            }),
            Box::new(Expr {
                kind: new_path!(sub, $pt.0),
                span: $pt.1,
            })
        )
    };
    ($p0: expr, $p1: expr, $p2: expr) => {
        new_path!(recurs, new_path!($p0, $p1), $p2)
    };
    ($p0: expr, $p1: expr, $p2: expr, $p3: expr) => {
        new_path!(recurs, new_path!($p0, $p1, $p2), $p3)
    };
    ($p0: expr, $p1: expr, $p2: expr, $p3: expr, $p4: expr) => {
        new_path!(recurs, new_path!($p0, $p1, $p2, $p3), $p4)
    };
}

// the best optimization I can think of
fn to_path_impl(path: &[(InternedString, Span)]) -> ExprKind {
    assert!(!path.is_empty(), "Internal Compiler Error DD4626E9B3A");

    if path.len() < 4 {

        if path.len() == 1 {
            new_path!(path[0])
        }

        else if path.len() == 2 {
            new_path!(path[0], path[1])
        }

        else {
            new_path!(path[0], path[1], path[2])
        }

    }

    else {

        if path.len() == 4 {
            new_path!(path[0], path[1], path[2], path[3])
        }

        else if path.len() == 5 {
            new_path!(path[0], path[1], path[2], path[3], path[4])
        }

        else {
            new_path!(recurs, to_path_impl(&path[0..(path.len() - 1)]), path[path.len() - 1])
        }

    }
}

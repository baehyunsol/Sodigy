use crate::ErrorToken;
use sodigy_file::{GetFilePathError, ModulePath};
use sodigy_name_analysis::NameKind;
use sodigy_string::InternedString;
use sodigy_token::InfixOp;

mod render;

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum ErrorKind {
    InvalidNumberLiteral,
    InvalidStringLiteralPrefix,
    InvalidCharacterInIdent(char),
    WrongNumberOfQuotesInRawStringLiteral,
    UnterminatedStringLiteral,
    NotAllowedCharInFormattedString(u8),
    UnmatchedBraceInFormattedString,
    EmptyBraceInFormattedString,
    DotDotDot,
    InvalidCharLiteral,
    InvalidCharLiteralPrefix,
    UnterminatedCharLiteral,
    InvalidByteLiteral,
    InvalidEscape,
    EmptyCharLiteral,
    UnterminatedBlockComment,
    InvalidUtf8,
    InvalidUnicodeCharacter,
    InvalidUnicodeEscape,
    UnmatchedGroup {
        expected: u8,
        got: u8,
    },

    // You can use up to 127 quotes for opening or 254 quotes (open 127 + close 127) consecutively.
    TooManyQuotes,
    UnclosedDelimiter(u8),
    UnexpectedToken {
        expected: ErrorToken,
        got: ErrorToken,
    },
    UnexpectedEof {
        expected: ErrorToken,
    },
    // It's like Eof, but an end of a group (parenthesis, braces or brackets).
    UnexpectedEog {
        expected: ErrorToken,
    },

    MissingDocComment,
    DocCommentNotAllowed,
    ModuleDocCommentNotAtTop,
    MissingDecorator(InternedString),
    DecoratorNotAllowed,
    UnexpectedDecorator(InternedString),
    ModuleDecoratorNotAtTop,
    MissingVisibility,
    CannotBePublic,
    FunctionWithoutBody,
    BlockWithoutValue,
    StructWithoutField,
    EmptyCurlyBraceBlock,
    PositionalArgAfterKeywordArg,
    NonDefaultValueAfterDefaultValue,
    CannotDeclareInlineModule,
    InclusiveRangeWithNoEnd,
    MultipleDotDotsInPattern,
    DifferentNameBindingsInOrPattern,
    InvalidFnType,
    EmptyMatchStatement,
    RedundantDecorator(InternedString),

    // TODO: suggest similar names
    // TODO: tell what it's trying to decorator
    InvalidDecorator(InternedString),
    MissingDecoratorArgument {
        expected: usize,
        got: usize,
    },
    UnexpectedDecoratorArgument {
        expected: usize,
        got: usize,
    },
    WrongNumberOfLangItemGenerics {
        lang_items: usize,
        generic_def: usize,
    },

    // Syntax errors in patterns
    InvalidRangePattern,
    CannotBindNameToAnotherName(InternedString),
    CannotBindNameToConstant(InternedString),
    CannotAnnotateType,
    RedundantNameBinding(InternedString, InternedString),
    CannotEvaluateConstPattern,

    NameCollision {
        name: InternedString,

        // TODO
        // context: NameCollisionContext,
    },
    CyclicLet {
        names: Vec<InternedString>,
    },
    CyclicAlias {
        names: Vec<InternedString>,
    },

    // TODO: suggest similar names
    UndefinedName(InternedString),

    KeywordArgumentRepeated(InternedString),
    KeywordArgumentNotAllowed,
    AliasResolveRecursionLimitReached,
    MissingTypeParameter {
        expected: usize,
        got: usize,
    },
    UnexpectedTypeParameter {
        expected: usize,
        got: usize,
    },
    MissingKeywordArgument(InternedString),

    // TODO: suggest similar names
    InvalidKeywordArgument(InternedString),

    // TODO: We need more helpful error variants
    //       e.g. if we know the types, we can guess which parameter is missing, or surplus, or in different order
    MissingFunctionParameter {
        expected: usize,
        got: usize,
    },
    UnexpectedFunctionParameter {
        expected: usize,
        got: usize,
    },

    StructFieldRepeated(InternedString),
    MissingStructField(InternedString),

    // TODO: suggest similar name
    InvalidStructField(InternedString),

    DependentTypeNotAllowed,

    // These type errors are generated by `mir-type` crate, and the crate uses its own data types
    // to represent types. But this crate cannot depend on `mir-type`, so those are types are
    // converted to string.
    UnexpectedType {
        expected: String,
        got: String,
    },
    CannotInferType {
        id: Option<InternedString>,
    },
    PartiallyInferedType {
        id: Option<InternedString>,
        r#type: String,
    },
    CannotInferGenericType {
        id: Option<String>,
    },
    PartiallyInferedGenericType {
        id: Option<String>,
        r#type: String,
    },
    CannotApplyInfixOp {
        op: InfixOp,
        arg_types: Vec<String>,
    },
    CannotSpecializePolyGeneric {
        num_candidates: usize,
    },
    MultipleModuleFiles {
        module: ModulePath,
        found_files: Vec<String>,
    },
    ModuleFileNotFound {
        module: ModulePath,
        candidates: Vec<String>,
    },
    LibFileNotFound,

    // --- warnings from here ---

    // If a function has 5 parameters and 3 of them are unused,
    // it throws 1 warning instead of 3.
    UnusedNames {
        names: Vec<InternedString>,
        kind: NameKind,
    },

    // not implemented feature in compiler
    Todo {
        // Give an arbitrary number so that it's easy to Ctrl+Shift+F
        id: u32,
        message: String,
    },
}

impl From<GetFilePathError> for ErrorKind {
    fn from(e: GetFilePathError) -> ErrorKind {
        if e.is_std && e.found_files.is_empty() {
            ErrorKind::LibFileNotFound
        }

        else if e.found_files.is_empty() {
            ErrorKind::ModuleFileNotFound {
                module: e.module_path.clone(),
                candidates: e.candidates.clone(),
            }
        }

        else if e.found_files.len() > 1 {
            ErrorKind::MultipleModuleFiles {
                module: e.module_path.clone(),
                found_files: e.found_files.clone(),
            }
        }

        else {
            unreachable!()
        }
    }
}

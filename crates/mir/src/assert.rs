use crate::{Expr, If, Session};
use sodigy_hir as hir;
use sodigy_span::Span;
use sodigy_string::InternedString;

#[derive(Clone, Debug)]
pub struct Assert {
    // TODO: keep it `Option<InternedString>` and make the compiler name it
    //       vs
    //       make it `InternedString` and give it a name with some hashes
    pub name: Option<InternedString>,
    pub keyword_span: Span,
    pub always: bool,

    // These two fields are only for type-checking. The compiler usees `exec` field to execut this assertion.
    pub note: Option<Expr>,
    pub value: Expr,

    // It's generated by compiler, and not type-checked.
    pub exec: Expr,
}

impl Assert {
    pub fn from_hir(hir_assert: &hir::Assert, session: &mut Session) -> Result<Assert, ()> {
        let mut has_error = false;

        let note = match hir_assert.note.as_ref().map(|note| Expr::from_hir(note, session)) {
            Some(Ok(note)) => Some(note),
            Some(Err(())) => {
                has_error = true;
                None
            },
            None => None,
        };

        let value = match Expr::from_hir(&hir_assert.value, session) {
            Ok(value) => Some(value),
            Err(()) => {
                has_error = true;
                None
            },
        };


        if has_error {
            Err(())
        }

        else {
            let value = value.unwrap();

            // if cond { _ } else { panic() }
            let exec = Expr::If(If {
                if_span: Span::None,
                cond: Box::new(value.clone()),
                else_span: Span::None,

                // TODO: I'm using dummy values because I'm too lazy to implement this...
                true_value: Box::new(Expr::Number {
                    n: sodigy_number::InternedNumber::from_u32(0, true),
                    span: Span::None,
                }),
                false_value: Box::new(Expr::Number {
                    n: sodigy_number::InternedNumber::from_u32(0, true),
                    span: Span::None,
                }),
            });

            Ok(Assert {
                name: hir_assert.name,
                keyword_span: hir_assert.keyword_span,
                always: hir_assert.always,
                note,
                value,
                exec,
            })
        }
    }
}

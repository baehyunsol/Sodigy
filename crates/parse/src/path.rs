use crate::Type;
use sodigy_span::Span;
use sodigy_string::InternedString;

#[derive(Clone, Debug)]
pub struct Path {
    pub id: InternedString,
    pub id_span: Span,
    pub fields: Vec<Field>,

    // `foo.bar.<T>.baz.bor.<U, V>()`
    // ->
    // `{ id: foo, fields: [bar, baz, bor], types: [None, Some([T]), None, Some([U, V])]}`
    pub types: Vec<Option<Vec<Type>>>,
}

impl Path {
    pub fn error_span_narrow(&self) -> Span {
        match self.fields.get(0) {
            Some(Field::Name { dot_span, .. }) => *dot_span,
            _ => self.id_span,
        }
    }

    // TODO: dump dotfish
    pub fn error_span_wide(&self) -> Span {
        let mut span = self.id_span;

        for field in self.fields.iter() {
            match field {
                Field::Name { dot_span, name_span, .. } => {
                    span = span.merge(*dot_span);
                    span = span.merge(*name_span);
                },
                _ => todo!(),
            }
        }

        span
    }

    // TODO: dump dotfish
    pub fn unintern_or_default(&self, intermediate_dir: &str) -> String {
        let mut result = self.id.unintern_or_default(intermediate_dir);

        for field in self.fields.iter() {
            match field {
                Field::Name { name, .. } => {
                    result = format!("{result}.{}", name.unintern_or_default(intermediate_dir));
                },
                _ => todo!(),
            }
        }

        result
    }
}

/// Variants other than `Name` are generated by the compiler.
/// Even though the user code is `a._0`, it won't be parsed to `Field::Index(0)`.
/// It'll first be parsed to `Field::Name("_0")`, then very later (after mir) lowered
/// to `Field::Index(0)`.
#[derive(Clone, Copy, Debug)]
pub enum Field {
    Name {
        name: InternedString,
        name_span: Span,
        dot_span: Span,
        is_from_alias: bool,
    },

    /// In `let (_, x) = foo()`, `x` is `Index(1)` of `foo()`.
    /// In `let (_, _, .., x) = foo()`, `x` is `Index(-1)` of `foo()`.
    Index(i64),

    /// 1. In `let (_, _, x @ .., _, _, _) = foo()`, `x` is `Range(2, -3)` of `foo()`.
    /// 2. In `let ([_] ++ x ++ [_]) = foo()`, `x` is `Range(1, -1)` of `foo()`.
    ///
    /// I'm not sure whether I should implement 1, but 2 must be implemented.
    Range(i64, i64),

    /// Returns a variant index of an enum value.
    Variant,

    /// Special field for pattern analysis.
    Constructor,

    /// Special field for pattern analysis.
    Payload,
}

impl Field {
    pub fn dot_span(&self) -> Option<Span> {
        match self {
            Field::Name { dot_span, .. } => Some(*dot_span),
            Field::Index(_) |
            Field::Range(_, _) |
            Field::Variant |
            Field::Constructor |
            Field::Payload => None,
        }
    }

    pub fn unwrap_name(&self) -> InternedString {
        match self {
            Field::Name { name, .. } => *name,
            _ => panic!(),
        }
    }

    pub fn unwrap_name_span(&self) -> Span {
        match self {
            Field::Name { name_span, .. } => *name_span,
            _ => panic!(),
        }
    }
}

pub fn merge_field_spans(fields: &[Field]) -> Span {
    let mut span = Span::None;

    for field in fields.iter() {
        match field {
            Field::Name { dot_span, name_span, .. } => {
                span = span.merge(*dot_span);
                span = span.merge(*name_span);
            },
            _ => {},
        }
    }

    span
}

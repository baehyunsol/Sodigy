use crate::{Block, CallArg, FuncArgDef, If, StructInitField, Tokens};
use sodigy_error::{Error, ErrorKind};
use sodigy_keyword::Keyword;
use sodigy_number::InternedNumber;
use sodigy_span::Span;
use sodigy_string::InternedString;
use sodigy_token::{
    Delim,
    ErrorToken,
    InfixOp,
    PostfixOp,
    Punct,
    Token,
    TokenKind,
};

#[derive(Clone, Debug)]
pub enum Expr {
    Identifier {
        id: InternedString,
        span: Span,
    },
    Number {
        n: InternedNumber,
        span: Span,
    },
    String {
        binary: bool,
        s: InternedString,

        // it includes quotes
        span: Span,
    },
    If(If),
    Block(Block),
    Call {
        func: Box<Expr>,
        args: Vec<CallArg>,
    },
    Tuple {
        elements: Vec<Expr>,
        group_span: Span,
    },
    StructInit {
        r#struct: Box<Expr>,
        fields: Vec<StructInitField>,
    },
    Path {
        lhs: Box<Expr>,
        field: Field,
    },
    FieldModifier {
        fields: Vec<(InternedString, Span)>,
        lhs: Box<Expr>,
        rhs: Box<Expr>,
    },
    Lambda {
        args: Vec<FuncArgDef>,
        r#type: Box<Option<Expr>>,
        value: Box<Expr>,
    },
    InfixOp {
        op: InfixOp,
        lhs: Box<Expr>,
        rhs: Box<Expr>,
    },
}

impl Expr {
    // Returns a best-effort span for error messages.
    pub fn error_span(&self) -> Span {
        match self {
            Expr::Identifier { span, .. } |
            Expr::Number { span, .. } |
            Expr::String { span, .. } => *span,
            Expr::If(r#if) => r#if.if_span,
            _ => todo!(),
        }
    }
}

#[derive(Clone, Debug)]
pub enum Field {
    // variants other than `Name` are generated by the compiler
    Name {
        name: InternedString,
        span: Span,
    },

    /// In `let pat (_, $x) = foo()`, `$x` is `Index(1)` of `foo()`.
    /// In `let pat (_, _, .., $x) = foo()`, `$x` is `Index(-1)` of `foo()`.
    Index(i64),

    /// In `let pat (_, _, $x @ .., _, _, _) = foo()`, `$x` is `Range(2, -3)` of `foo()`.
    Range(i64, i64),
}

impl<'t> Tokens<'t> {
    pub fn parse_expr(&mut self) -> Result<Expr, Vec<Error>> {
        self.pratt_parse(0)
    }

    fn pratt_parse(
        &mut self,
        min_bp: u32,
    ) -> Result<Expr, Vec<Error>> {
        let mut lhs = match self.peek() {
            Some(Token { kind: TokenKind::Identifier(id), span }) => {
                let (id, span) = (*id, *span);
                self.cursor += 1;
                Expr::Identifier { id, span }
            },
            Some(Token { kind: TokenKind::Number(n), span }) => {
                let (n, span) = (*n, *span);
                self.cursor += 1;
                Expr::Number { n, span }
            },
            Some(Token { kind: TokenKind::String { binary, s, .. }, span }) => {
                let (binary, s, span) = (*binary, *s, *span);
                self.cursor += 1;
                Expr::String { binary, s, span }
            },
            Some(Token { kind: TokenKind::Keyword(Keyword::If), .. }) => Expr::If(self.parse_if_expr()?),
            Some(Token { kind: TokenKind::Group { delim, tokens }, span }) => match delim {
                Delim::Lambda => {
                    let mut tokens = Tokens::new(tokens, span.end());
                    let args = tokens.parse_func_arg_defs()?;
                    self.cursor += 1;
                    let mut r#type = None;

                    match self.peek() {
                        Some(Token { kind: TokenKind::Punct(Punct::Colon), .. }) => {
                            self.cursor += 1;
                            r#type = Some(self.parse_expr()?);
                        },
                        _ => {},
                    }

                    self.match_and_pop(TokenKind::Punct(Punct::Arrow))?;
                    let value = self.parse_expr()?;

                    Expr::Lambda {
                        args,
                        r#type: Box::new(r#type),
                        value: Box::new(value),
                    }
                },
                Delim::Parenthesis => {
                    let span = *span;
                    let mut tokens = Tokens::new(tokens, span.end());
                    let exprs = tokens.parse_comma_separated_expr()?;
                    let mut is_tuple = exprs.len() != 1;

                    // `(a + b)` is just an expression, but `(a + b,)` is a tuple
                    if exprs.len() == 1 && matches!(
                        tokens.last(),
                        Some(Token { kind: TokenKind::Punct(Punct::Comma), .. }),
                    ) {
                        is_tuple = true;
                    }

                    self.cursor += 1;

                    if is_tuple {
                        Expr::Tuple {
                            elements: exprs,
                            group_span: span,
                        }
                    }

                    else {
                        exprs[0].clone()
                    }
                },
                Delim::Brace => {
                    let mut tokens = Tokens::new(tokens, span.end());
                    let block = tokens.parse_block(false /* top_level */)?;
                    self.cursor += 1;

                    Expr::Block(block)
                },
                Delim::Bracket => todo!(),
            },
            Some(t) => panic!("TODO: {t:?}"),
            None => {
                return Err(vec![self.unexpected_end(ErrorToken::Expr)]);
            },
        };

        loop {
            match self.peek() {
                Some(Token {
                    kind: TokenKind::Punct(p),
                    span,
                }) => {
                    let punct = *p;
                    let punct_span = *span;

                    match PostfixOp::try_from(punct) {
                        // `..` can be both infix and postfix!
                        Ok(op @ PostfixOp::Range) => todo!(),
                        Ok(op) => todo!(),
                        Err(_) => {
                            // let's try infix
                        },
                    }

                    // path operator
                    if let Punct::Dot = punct {
                        let (l_bp, _) = path_binding_power();

                        if l_bp < min_bp {
                            break;
                        }

                        self.cursor += 1;
                        let (name, name_span) = self.pop_name_and_span()?;
                        lhs = Expr::Path {
                            lhs: Box::new(lhs),
                            field: Field::Name {
                                name,
                                span: name_span,
                            },
                        };
                        continue;
                    }

                    match InfixOp::try_from(punct) {
                        Ok(op) => {
                            let (l_bp, r_bp) = infix_binding_power(op);

                            if l_bp < min_bp {
                                break;
                            }

                            self.cursor += 1;
                            let rhs = self.pratt_parse(r_bp)?;
                            lhs = Expr::InfixOp {
                                op,
                                lhs: Box::new(lhs),
                                rhs: Box::new(rhs),
                            };
                            continue;
                        },
                        Err(_) => {
                            // Okay, `punct` is not an operator. we should not touch this.
                            break;
                        },
                    }
                },
                Some(Token {
                    kind: TokenKind::Group { delim, tokens },
                    span,
                }) => {
                    let span = *span;

                    match delim {
                        Delim::Lambda => todo!(),
                        // call
                        Delim::Parenthesis => {
                            let (l_bp, _) = call_binding_power();

                            if l_bp < min_bp {
                                break;
                            }

                            let mut tokens = Tokens::new(tokens, span.end());
                            let args = tokens.parse_call_args()?;
                            self.cursor += 1;
                            lhs = Expr::Call {
                                func: Box::new(lhs),
                                args,
                            };
                            continue;
                        },
                        // struct initialization
                        // there are multiple cases:
                        // `if foo { 3 }` is valid, but it's not a struct initialization
                        // `if foo { bar: 3 }` is valid, and is a struct initialization
                        Delim::Brace => {
                            let (l_bp, _) = struct_init_binding_power();

                            if l_bp < min_bp {
                                break;
                            }

                            let mut tokens = Tokens::new(tokens, span.end());

                            match tokens.try_parse_struct_initialization() {
                                Some(Ok(s)) => {
                                    self.cursor += 1;
                                    lhs = Expr::StructInit {
                                        r#struct: Box::new(lhs),
                                        fields: s,
                                    };
                                    continue;
                                },

                                // it's a struct initialization,
                                // but there's a synax error
                                Some(Err(e)) => {
                                    return Err(e);
                                },

                                // not a struct initialization
                                None => {
                                    break;
                                },
                            }
                        },
                        // index
                        Delim::Bracket => todo!(),
                    }
                },
                Some(Token {
                    kind: TokenKind::FieldModifier(field),
                    span,
                }) => {
                    let (l_bp, r_bp) = field_modifier_binding_power();

                    if l_bp < min_bp {
                        break;
                    }

                    let mut fields = vec![(*field, *span)];
                    self.cursor += 1;

                    while let Some(Token {
                        kind: TokenKind::FieldModifier(field),
                        span,
                    }) = self.peek() {
                        fields.push((*field, *span));
                        self.cursor += 1;
                    }

                    let rhs = self.pratt_parse(r_bp)?;
                    lhs = Expr::FieldModifier {
                        fields,
                        lhs: Box::new(lhs),
                        rhs: Box::new(rhs),
                    };
                    continue;
                },
                None => {
                    return Ok(lhs);
                },
                t => panic!("TODO: {t:?}"),
            }
        }

        Ok(lhs)
    }

    pub fn parse_comma_separated_expr(&mut self) -> Result<Vec<Expr>, Vec<Error>> {
        let mut exprs = vec![];

        if self.peek().is_none() {
            return Ok(exprs);
        }

        loop {
            exprs.push(self.parse_expr()?);

            match self.peek2() {
                (
                    Some(Token { kind: TokenKind::Punct(Punct::Comma), .. }),
                    Some(_),
                ) => {
                    self.cursor += 1;
                },
                (
                    Some(Token { kind: TokenKind::Punct(Punct::Comma), .. }),
                    None,
                ) => {
                    self.cursor += 1;
                    break;
                },
                (None, _) => {
                    break;
                },
                (Some(t), _) => {
                    return Err(vec![Error {
                        kind: ErrorKind::UnexpectedToken {
                            expected: ErrorToken::Punct(Punct::Comma),
                            got: (&t.kind).into(),
                        },
                        span: t.span,
                        ..Error::default()
                    }]);
                },
            }
        }

        Ok(exprs)
    }
}

fn path_binding_power() -> (u32, u32) {
    (PATH, PATH + 1)
}

fn struct_init_binding_power() -> (u32, u32) {
    (STRUCT_INIT, STRUCT_INIT + 1)
}

fn call_binding_power() -> (u32, u32) {
    (CALL, CALL + 1)
}

fn field_modifier_binding_power() -> (u32, u32) {
    (MODIFY, MODIFY + 1)
}

fn infix_binding_power(op: InfixOp) -> (u32, u32) {
    match op {
        InfixOp::Add | InfixOp::Sub => (ADD, ADD + 1),
        InfixOp::Mul | InfixOp::Div | InfixOp::Rem => (MUL, MUL + 1),
        InfixOp::Lt | InfixOp::Gt | InfixOp::Leq | InfixOp::Geq => (COMP, COMP + 1),
        InfixOp::Eq | InfixOp::Neq => (COMP_EQ, COMP_EQ + 1),
        InfixOp::Shl | InfixOp::Shr => (SHIFT, SHIFT + 1),
    }
}

const PATH: u32 = 37;  // a.b
const STRUCT_INIT: u32 = 35;  // foo { a: 1, b: 2 }
const CALL: u32 = 33;  // foo()
const INDEX: u32 = 31;  // a[3]
const QUESTION: u32 = 29;  // a?
const NEG: u32 = 27;  // -a
const MUL: u32 = 25;  // a * b, a / b, a % b
const ADD: u32 = 23;  // a + b, a - b
const SHIFT: u32 = 21;  // a << b, a >> b
const BITWISE_AND: u32 = 19;  // a & b
const XOR: u32 = 17;  // a ^ b
const BITWISE_OR: u32 = 15;  // a | b

// TODO: Do we need a concat operator?
// RANGE: a..b, a..=b, a.., ..a
const CONCAT: u32 = 11; const RANGE: u32 = 11;
const COMP: u32 = 9;  // a < b, a > b, a <= b, a >= b
const COMP_EQ: u32 = 7;  // a == b, a != b
const MODIFY: u32 = 5;  // p `age 32
const LOGICAL_AND: u32 = 3;  // a && b
const LOGICAL_OR: u32 = 1;  // a || b

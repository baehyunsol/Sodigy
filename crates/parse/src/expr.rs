use crate::{
    Block,
    CallArg,
    FuncArgDef,
    If,
    Match,
    StructInitField,
    Tokens,
    Type,
};
use sodigy_error::{Error, ErrorKind, ErrorToken};
use sodigy_number::InternedNumber;
use sodigy_span::Span;
use sodigy_string::InternedString;
use sodigy_token::{
    Delim,
    InfixOp,
    Keyword,
    PostfixOp,
    PrefixOp,
    Punct,
    Token,
    TokenKind,
};

#[derive(Clone, Debug)]
pub enum Expr {
    Identifier {
        id: InternedString,
        span: Span,
    },
    Number {
        n: InternedNumber,
        span: Span,
    },
    String {
        binary: bool,
        s: InternedString,

        // it includes quotes
        span: Span,
    },
    Char {
        ch: u32,

        // it includes quotes
        span: Span,
    },
    Byte {
        b: u8,
        span: Span,
    },
    If(If),
    Match(Match),
    Block(Block),
    Call {
        func: Box<Expr>,
        args: Vec<CallArg>,
    },
    Tuple {
        elements: Vec<Expr>,
        group_span: Span,
    },
    List {
        elements: Vec<Expr>,
        group_span: Span,
    },
    StructInit {
        r#struct: Box<Expr>,
        fields: Vec<StructInitField>,
        group_span: Span,
    },
    Path {
        lhs: Box<Expr>,
        field: Field,
    },
    FieldModifier {
        fields: Vec<(InternedString, Span)>,
        lhs: Box<Expr>,
        rhs: Box<Expr>,
    },
    Lambda {
        args: Vec<FuncArgDef>,
        r#type: Box<Option<Type>>,
        value: Box<Expr>,
        group_span: Span,
    },
    PrefixOp {
        op: PrefixOp,
        op_span: Span,
        rhs: Box<Expr>,
    },
    InfixOp {
        op: InfixOp,
        op_span: Span,
        lhs: Box<Expr>,
        rhs: Box<Expr>,
    },
    PostfixOp {
        op: PostfixOp,
        op_span: Span,
        lhs: Box<Expr>,
    },
}

impl Expr {
    // Returns a best-effort span for error messages.
    pub fn error_span(&self) -> Span {
        match self {
            Expr::Identifier { span, .. } |
            Expr::Number { span, .. } |
            Expr::String { span, .. } |
            Expr::Char { span, .. } => *span,
            Expr::If(r#if) => r#if.if_span,
            _ => todo!(),
        }
    }

    pub fn block_or_expr(block: Block) -> Expr {
        if block.lets.is_empty() && block.funcs.is_empty() &&
            block.structs.is_empty() && block.enums.is_empty() &&
            block.modules.is_empty() && block.uses.is_empty() &&
            block.value.is_some()
        {
            block.value.unwrap()
        }

        else {
            Expr::Block(block)
        }
    }
}

#[derive(Clone, Copy, Debug)]
pub enum Field {
    // variants other than `Name` are generated by the compiler
    Name {
        name: InternedString,
        span: Span,
        dot_span: Span,
    },

    /// In `let pat (_, x) = foo()`, `x` is `Index(1)` of `foo()`.
    /// In `let pat (_, _, .., x) = foo()`, `x` is `Index(-1)` of `foo()`.
    Index(i64),

    /// In `let pat (_, _, x @ .., _, _, _) = foo()`, `x` is `Range(2, -3)` of `foo()`.
    Range(i64, i64),
}

impl Field {
    pub fn dot_span(&self) -> Option<Span> {
        match self {
            Field::Name { dot_span, .. } => Some(*dot_span),
            Field::Index(_) | Field::Range(_, _) => None,
        }
    }

    pub fn unwrap_name(&self) -> InternedString {
        match self {
            Field::Name { name, .. } => *name,
            _ => panic!(),
        }
    }

    pub fn unwrap_span(&self) -> Span {
        match self {
            Field::Name { span, .. } => *span,
            _ => panic!(),
        }
    }
}

impl<'t> Tokens<'t> {
    pub fn parse_expr(&mut self) -> Result<Expr, Vec<Error>> {
        self.pratt_parse(0)
    }

    fn pratt_parse(
        &mut self,
        min_bp: u32,
    ) -> Result<Expr, Vec<Error>> {
        let mut lhs = match self.peek() {
            Some(Token { kind: tk @ TokenKind::Punct(p), span }) => {
                let punct = *p;
                let punct_span = *span;

                match PrefixOp::try_from(punct) {
                    Ok(op) => {
                        let bp = prefix_binding_power(op);
                        self.cursor += 1;
                        let rhs = self.pratt_parse(bp)?;
                        Expr::PrefixOp {
                            op,
                            op_span: punct_span,
                            rhs: Box::new(rhs),
                        }
                    },
                    Err(_) => {
                        return Err(vec![Error {
                            kind: ErrorKind::UnexpectedToken {
                                expected: ErrorToken::Expr,
                                got: ErrorToken::Punct(punct),
                            },
                            spans: punct_span.simple_error(),
                            note: Some(format!("`{}` is not a prefix operator.", p.render_error())),
                        }]);
                    },
                }
            },
            Some(Token { kind: TokenKind::Identifier(id), span }) => {
                let (id, span) = (*id, *span);
                self.cursor += 1;
                Expr::Identifier { id, span }
            },
            Some(Token { kind: TokenKind::Number(n), span }) => {
                let (n, span) = (n.clone(), *span);
                self.cursor += 1;
                Expr::Number { n, span }
            },
            Some(Token { kind: TokenKind::String { binary, s, .. }, span }) => {
                let (binary, s, span) = (*binary, *s, *span);
                self.cursor += 1;
                Expr::String { binary, s, span }
            },
            Some(Token { kind: TokenKind::Char(ch), span }) => {
                let (ch, span) = (*ch, *span);
                self.cursor += 1;
                Expr::Char { ch, span }
            },
            Some(Token { kind: TokenKind::Byte(b), span }) => {
                let (b, span) = (*b, *span);
                self.cursor += 1;
                Expr::Byte { b, span }
            },
            Some(Token { kind: TokenKind::Keyword(Keyword::If), .. }) => Expr::If(self.parse_if_expr()?),
            Some(Token { kind: TokenKind::Keyword(Keyword::Match), .. }) => Expr::Match(self.parse_match_expr()?),
            Some(Token { kind: TokenKind::Group { delim, tokens }, span }) => match delim {
                Delim::Lambda => {
                    let span = *span;
                    let mut tokens = Tokens::new(tokens, span.end());
                    let args = tokens.parse_func_arg_defs()?;
                    self.cursor += 1;
                    let mut r#type = None;

                    match self.peek() {
                        Some(Token { kind: TokenKind::Punct(Punct::Colon), .. }) => {
                            self.cursor += 1;
                            r#type = Some(self.parse_type()?);
                        },
                        _ => {},
                    }

                    self.match_and_pop(TokenKind::Punct(Punct::Arrow))?;
                    let value = self.parse_expr()?;

                    Expr::Lambda {
                        args,
                        r#type: Box::new(r#type),
                        value: Box::new(value),
                        group_span: span,
                    }
                },
                Delim::Parenthesis => {
                    let span = *span;
                    let mut tokens = Tokens::new(tokens, span.end());
                    let exprs = tokens.parse_exprs()?;
                    let mut is_tuple = exprs.len() != 1;

                    // `(a + b)` is just an expression, but `(a + b,)` is a tuple
                    if exprs.len() == 1 && matches!(
                        tokens.last(),
                        Some(Token { kind: TokenKind::Punct(Punct::Comma), .. }),
                    ) {
                        is_tuple = true;
                    }

                    self.cursor += 1;

                    if is_tuple {
                        Expr::Tuple {
                            elements: exprs,
                            group_span: span,
                        }
                    }

                    else {
                        exprs[0].clone()
                    }
                },
                Delim::Brace => {
                    let span = *span;
                    let mut tokens = Tokens::new(tokens, span.end());
                    let block = tokens.parse_block(false /* top_level */, span)?;
                    self.cursor += 1;

                    Expr::Block(block)
                },
                Delim::Bracket => {
                    let span = *span;
                    let mut tokens = Tokens::new(tokens, span.end());
                    let exprs = tokens.parse_exprs()?;
                    self.cursor += 1;

                    Expr::List {
                        elements: exprs,
                        group_span: span,
                    }
                },
            },
            Some(t) => panic!("TODO: {t:?}"),
            None => {
                return Err(vec![self.unexpected_end(ErrorToken::Expr)]);
            },
        };

        loop {
            match self.peek() {
                Some(Token {
                    kind: TokenKind::Punct(p),
                    span,
                }) => {
                    let punct = *p;
                    let punct_span = *span;

                    match PostfixOp::try_from(punct) {
                        // `..` and `..=` can be both infix and postfix!
                        Ok(op @ PostfixOp::Range { inclusive }) => {
                            let bp = postfix_binding_power(op);

                            if bp < min_bp {
                                break;
                            }

                            self.cursor += 1;

                            match self.peek().map(|t| t.expr_begin()) {
                                Some(true) => {
                                    let rhs = self.pratt_parse(bp)?;
                                    lhs = Expr::InfixOp {
                                        op: InfixOp::Range { inclusive },
                                        op_span: punct_span,
                                        lhs: Box::new(lhs),
                                        rhs: Box::new(rhs),
                                    };
                                },
                                _ => {
                                    lhs = Expr::PostfixOp {
                                        op,
                                        op_span: punct_span,
                                        lhs: Box::new(lhs),
                                    };
                                },
                            }

                            continue;
                        },
                        Ok(op) => {
                            let bp = postfix_binding_power(op);

                            if bp < min_bp {
                                break;
                            }

                            self.cursor += 1;
                            lhs = Expr::PostfixOp {
                                op,
                                op_span: punct_span,
                                lhs: Box::new(lhs),
                            };
                            continue;
                        },
                        Err(_) => {
                            // let's try infix
                        },
                    }

                    // path operator
                    if let Punct::Dot = punct {
                        let (l_bp, _) = path_binding_power();

                        if l_bp < min_bp {
                            break;
                        }

                        self.cursor += 1;
                        let (name, name_span) = self.pop_name_and_span()?;
                        lhs = Expr::Path {
                            lhs: Box::new(lhs),
                            field: Field::Name {
                                name,
                                span: name_span,
                                dot_span: punct_span,
                            },
                        };
                        continue;
                    }

                    match InfixOp::try_from(punct) {
                        Ok(op) => {
                            let (l_bp, r_bp) = infix_binding_power(op);

                            if l_bp < min_bp {
                                break;
                            }

                            self.cursor += 1;
                            let rhs = self.pratt_parse(r_bp)?;
                            lhs = Expr::InfixOp {
                                op,
                                op_span: punct_span,
                                lhs: Box::new(lhs),
                                rhs: Box::new(rhs),
                            };
                            continue;
                        },
                        Err(_) => {
                            // Okay, `punct` is not an operator. we should not touch this.
                            break;
                        },
                    }
                },
                Some(Token {
                    kind: TokenKind::Group { delim, tokens },
                    span,
                }) => {
                    let span = *span;

                    match delim {
                        Delim::Lambda => todo!(),
                        // call
                        Delim::Parenthesis => {
                            let (l_bp, _) = call_binding_power();

                            if l_bp < min_bp {
                                break;
                            }

                            let mut tokens = Tokens::new(tokens, span.end());
                            let args = tokens.parse_call_args()?;
                            self.cursor += 1;
                            lhs = Expr::Call {
                                func: Box::new(lhs),
                                args,
                            };
                            continue;
                        },
                        // struct initialization
                        // there are multiple cases:
                        // `if foo { 3 }` is valid, but it's not a struct initialization
                        // `if foo { bar: 3 }` is valid, and is a struct initialization
                        Delim::Brace => {
                            let (l_bp, _) = struct_init_binding_power();

                            if l_bp < min_bp {
                                break;
                            }

                            let mut tokens = Tokens::new(tokens, span.end());

                            match tokens.try_parse_struct_initialization() {
                                Some(Ok(s)) => {
                                    self.cursor += 1;
                                    lhs = Expr::StructInit {
                                        r#struct: Box::new(lhs),
                                        fields: s,
                                        group_span: span,
                                    };
                                    continue;
                                },

                                // it's a struct initialization,
                                // but there's a synax error
                                Some(Err(e)) => {
                                    return Err(e);
                                },

                                // not a struct initialization
                                None => {
                                    break;
                                },
                            }
                        },
                        // index
                        Delim::Bracket => {
                            let (l_bp, _) = infix_binding_power(InfixOp::Index);

                            if l_bp < min_bp {
                                break;
                            }

                            let mut tokens = Tokens::new(tokens, span.end());
                            let rhs = tokens.parse_expr()?;
                            self.cursor += 1;
                            lhs = Expr::InfixOp {
                                op: InfixOp::Index,
                                op_span: span,
                                lhs: Box::new(lhs),
                                rhs: Box::new(rhs),
                            };
                            continue;
                        },
                    }
                },
                Some(Token {
                    kind: TokenKind::FieldModifier(field),
                    span,
                }) => {
                    let (l_bp, r_bp) = field_modifier_binding_power();

                    if l_bp < min_bp {
                        break;
                    }

                    let mut fields = vec![(*field, *span)];
                    self.cursor += 1;

                    while let Some(Token {
                        kind: TokenKind::FieldModifier(field),
                        span,
                    }) = self.peek() {
                        fields.push((*field, *span));
                        self.cursor += 1;
                    }

                    let rhs = self.pratt_parse(r_bp)?;
                    lhs = Expr::FieldModifier {
                        fields,
                        lhs: Box::new(lhs),
                        rhs: Box::new(rhs),
                    };
                    continue;
                },
                Some(t) => panic!("TODO: {t:?}"),
                None => {
                    return Ok(lhs);
                },
            }
        }

        Ok(lhs)
    }

    pub fn parse_exprs(&mut self) -> Result<Vec<Expr>, Vec<Error>> {
        let mut exprs = vec![];

        if self.peek().is_none() {
            return Ok(exprs);
        }

        loop {
            exprs.push(self.parse_expr()?);

            match self.peek2() {
                (
                    Some(Token { kind: TokenKind::Punct(Punct::Comma), .. }),
                    Some(_),
                ) => {
                    self.cursor += 1;
                },
                (
                    Some(Token { kind: TokenKind::Punct(Punct::Comma), .. }),
                    None,
                ) => {
                    self.cursor += 1;
                    break;
                },
                (None, _) => {
                    break;
                },
                (Some(t), _) => {
                    return Err(vec![Error {
                        kind: ErrorKind::UnexpectedToken {
                            expected: ErrorToken::Punct(Punct::Comma),
                            got: (&t.kind).into(),
                        },
                        spans: t.span.simple_error(),
                        ..Error::default()
                    }]);
                },
            }
        }

        Ok(exprs)
    }
}

fn path_binding_power() -> (u32, u32) {
    (PATH, PATH + 1)
}

fn struct_init_binding_power() -> (u32, u32) {
    (STRUCT_INIT, STRUCT_INIT + 1)
}

fn call_binding_power() -> (u32, u32) {
    (CALL, CALL + 1)
}

fn field_modifier_binding_power() -> (u32, u32) {
    (MODIFY, MODIFY + 1)
}

fn prefix_binding_power(op: PrefixOp) -> u32 {
    match op {
        PrefixOp::Not | PrefixOp::Neg => NEG,
    }
}

fn infix_binding_power(op: InfixOp) -> (u32, u32) {
    match op {
        InfixOp::Add | InfixOp::Sub => (ADD, ADD + 1),
        InfixOp::Mul | InfixOp::Div | InfixOp::Rem => (MUL, MUL + 1),
        InfixOp::Lt | InfixOp::Gt | InfixOp::Leq | InfixOp::Geq => (COMP, COMP + 1),
        InfixOp::Eq | InfixOp::Neq => (COMP_EQ, COMP_EQ + 1),
        InfixOp::Shl | InfixOp::Shr => (SHIFT, SHIFT + 1),
        InfixOp::Index => (INDEX, INDEX + 1),
        InfixOp::Range { .. } => (RANGE, RANGE + 1),
        InfixOp::Concat => (CONCAT, CONCAT + 1),
        InfixOp::BitAnd => (BIT_AND, BIT_AND + 1),
        InfixOp::BitOr => (BIT_OR, BIT_OR + 1),
        InfixOp::LogicAnd => (LOGIC_AND, LOGIC_AND + 1),
        InfixOp::LogicOr => (LOGIC_OR, LOGIC_OR + 1),
    }
}

fn postfix_binding_power(op: PostfixOp) -> u32 {
    match op {
        PostfixOp::Range { .. } => RANGE,
        PostfixOp::QuestionMark => QUESTION,
    }
}

const PATH: u32 = 37;  // a.b
const STRUCT_INIT: u32 = 35;  // foo { a: 1, b: 2 }
const CALL: u32 = 33;  // foo()
const INDEX: u32 = 31;  // a[3]
const QUESTION: u32 = 29;  // a?
const NEG: u32 = 27;  // -a
const MUL: u32 = 25;  // a * b, a / b, a % b
const ADD: u32 = 23;  // a + b, a - b
const SHIFT: u32 = 21;  // a << b, a >> b
const BIT_AND: u32 = 19;  // a & b
const XOR: u32 = 17;  // a ^ b
const BIT_OR: u32 = 15;  // a | b

// RANGE: a..b, a..=b, a.., ..a
const CONCAT: u32 = 11; const RANGE: u32 = 11;
const COMP: u32 = 9;  // a < b, a > b, a <= b, a >= b
const COMP_EQ: u32 = 7;  // a == b, a != b
const MODIFY: u32 = 5;  // p `age 32
const LOGIC_AND: u32 = 3;  // a && b
const LOGIC_OR: u32 = 1;  // a || b

use crate::err::HirError;
use crate::expr::{lower_ast_expr, LocalDef};
use crate::names::{IdentWithOrigin, NameSpace};
use crate::session::HirSession;
use sodigy_ast::{self as ast, IdentWithSpan, PatternKind};
use sodigy_intern::InternedString;
use sodigy_span::SpanRange;
use std::collections::{HashMap, HashSet};

mod fmt;

pub struct Pattern {}

// `let Foo { bar: $x, baz: $y } = f();`
// -> `let $tmp = f();`, `let $x = $tmp.bar;`, `let $y = $tmp.baz;`
//
// `let Foo($x, $y, $z @ ..) = f();`
// -> TODO: `$z` should be a tuple!, there must be some kind of slice of tuples
//
// `let ($x, $y, .., $z, _) = f();`
// -> `let $tmp = f();`, `let $x = $tmp._0;`, `let $y = $tmp._1;`, `let $z = TODO`
// -> TODO: there must be some kind of slice of tuples for `$z`
//
// `let Foo { $x, $z @ .. } = f();`
// -> Invalid: No bindings for shorthand in this case
//
// `let Foo(Foo($x, $y), $z) = f();`
// -> `let $tmp = f();`, `let $tmp2 = $tmp._0;`, `let $x = $tmp2._0;`, `let $y = $tmp2._1;`, `let $z = $tmp._1;`
//
// `let Foo { bar: $x @ Foo { .. }, .. } = f();`
// -> same as `let Foo { bar: $x, .. } = f();`
//
// let's not allow `$x @ _` -> it makes sense but why would someone do this?
pub fn lower_patterns_to_name_bindings(
    pattern: &ast::Pattern,
    expr: &ast::Expr,

    // expressions are not lowered in this stage
    // the last element, boolean, indicates whether this name binding is
    // declared by user, or generated by the compiler
    name_bindings: &mut Vec<(IdentWithSpan, ast::Expr, bool)>,
    session: &mut HirSession,
) -> Result<(), ()> {
    match &pattern.kind {
        PatternKind::Binding(name) => {
            name_bindings.push((IdentWithSpan::new(*name, pattern.span), expr.clone(), true));
        },
        PatternKind::Tuple(patterns) => {
            for pattern in patterns.iter() {
                todo!();
            }
        },
        PatternKind::TupleStruct {
            name,
            fields,
        } => {
            for pattern in fields.iter() {
                todo!();
            }
        },
        PatternKind::Struct {
            struct_name,
            fields,
            ..
        } => {
            for ast::PatField {
                name,
                pattern,
            } in fields.iter() {
                todo!();
            }
        },
        _ => {
            session.push_error(HirError::refutable_pattern_in_let(pattern));
            return Err(());
        },
    }

    Ok(())
}

pub fn lower_ast_pattern(
    pattern: &ast::Pattern,
    session: &mut HirSession,
) -> Result<Pattern, ()> {
    session.push_error(HirError::todo("pattern", pattern.span));
    Err(())
}

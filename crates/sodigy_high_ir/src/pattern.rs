use crate::{Type, lower_ast_ty};
use crate::err::HirError;
use crate::names::{IdentWithOrigin, NameSpace};
use crate::session::HirSession;
use sodigy_ast::{self as ast, IdentWithSpan};
use sodigy_intern::InternedString;
use sodigy_span::SpanRange;
use std::collections::{HashMap, HashSet};

mod fmt;

pub struct Pattern {
    kind: PatternKind,
    span: SpanRange,
    ty: Option<Type>,
    bind: Option<IdentWithSpan>,
}

pub enum PatternKind {
    Binding(InternedString)
}

// `let Foo { bar: $x, baz: $y } = f();`
// -> `let $tmp = f();`, `let $x = $tmp.bar;`, `let $y = $tmp.baz;`
//
// `let Foo($x, $y, $z @ ..) = f();`
// -> TODO: `$z` should be a tuple!, there must be some kind of slice of tuples
//
// `let ($x, $y, .., $z, _) = f();`
// -> `let $tmp = f();`, `let $x = $tmp._0;`, `let $y = $tmp._1;`, `let $z = TODO`
// -> TODO: there must be some kind of slice of tuples for `$z`
//
// `let Foo { $x, $z @ .. } = f();`
// -> Invalid: No bindings for shorthand in this case
//
// `let Foo(Foo($x, $y), $z) = f();`
// -> `let $tmp = f();`, `let $tmp2 = $tmp._0;`, `let $x = $tmp2._0;`, `let $y = $tmp2._1;`, `let $z = $tmp._1;`
//
// `let Foo { bar: $x @ Foo { .. }, .. } = f();`
// -> same as `let Foo { bar: $x, .. } = f();`
//
// let's not allow `$x @ _` -> it makes sense but why would someone do this?
pub fn lower_patterns_to_name_bindings(
    pattern: &ast::Pattern,
    expr: &ast::Expr,

    // expressions are not lowered in this stage
    // the last element, boolean, indicates whether this name binding is
    // declared by user, or generated by the compiler
    name_bindings: &mut Vec<(IdentWithSpan, ast::Expr, bool)>,
    session: &mut HirSession,
) -> Result<(), ()> {
    match &pattern.kind {
        ast::PatternKind::Binding(name) => {
            // It's O(n), but `n` must be small enough in most cases
            for (prev, _, _) in name_bindings.iter() {
                if prev.id() == name {
                    session.push_error(HirError::name_collision(
                        *prev,
                        IdentWithSpan::new(*name, pattern.span),
                    ));

                    return Err(());
                }
            }

            name_bindings.push((IdentWithSpan::new(*name, pattern.span), expr.clone(), true));
        },
        ast::PatternKind::Tuple(patterns) => {
            for pattern in patterns.iter() {
                todo!();
            }
        },
        ast::PatternKind::TupleStruct {
            name,
            fields,
        } => {
            for pattern in fields.iter() {
                todo!();
            }
        },
        ast::PatternKind::Struct {
            struct_name,
            fields,
            ..
        } => {
            for ast::PatField {
                name,
                pattern,
            } in fields.iter() {
                todo!();
            }
        },
        _ => {
            session.push_error(HirError::refutable_pattern_in_let(pattern));
            return Err(());
        },
    }

    Ok(())
}

pub fn lower_ast_pattern(
    pattern: &ast::Pattern,
    session: &mut HirSession,
    used_names: &mut HashSet<IdentWithOrigin>,
    imports: &HashMap<InternedString, (SpanRange, Vec<IdentWithSpan>)>,
    name_space: &mut NameSpace,
) -> Result<Pattern, ()> {
    match &pattern.kind {
        ast::PatternKind::Binding(name) => Ok(Pattern {
            kind: PatternKind::Binding(*name),
            span: pattern.span,
            bind: pattern.bind,
            ty: if let Some(ty) = &pattern.ty {
                Some(lower_ast_ty(
                    &ty,
                    session,
                    used_names,
                    imports,
                    name_space,
                )?)
            } else {
                None
            }
        }),
        _ => {
            session.push_error(HirError::todo("pattern", pattern.span));

            Err(())
        },
    }
}
